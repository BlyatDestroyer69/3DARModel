<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Bukit Kiara 3D Map - Three.js</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #f0f0f0;
            color: #333;
        }
        #container {
            width: 100vw;
            height: 100vh;
            display: block;
            position: relative;
        }
        canvas {
            display: block;
            position: absolute; /* Make canvas explicitly positioned */
            top: 0;             /* Position at top */
            left: 0;            /* Position at left */
            z-index: 1;         /* Set a z-index lower than controls */
        }
        .hotspot-label {
            position: absolute;
            background-color: #3498db;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 14px;
            pointer-events: auto;
            cursor: pointer;
            user-select: none;
            white-space: nowrap;
            transform: translate(-50%, -100%); /* Center above the point */
            z-index: 2; /* Above canvas */
            display: none; /* Hidden by default */
            transition: opacity 0.2s ease-in-out;
            opacity: 0;
        }
        .hotspot-label.visible {
            opacity: 1;
        }
        .controls-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.85);
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 10;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .control-button {
            background-color: #007bff;
            color: white;
            padding: 8px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s ease;
        }
        .control-button:hover {
            background-color: #0056b3;
        }

        /* Loading Screen Styles */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: #2c3e50; /* Dark blue background */
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* Ensure it's on top */
            transition: opacity 0.5s ease-out;
        }

        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none; /* Disable interaction when hidden */
        }

        .spinner {
            border: 8px solid rgba(255, 255, 255, 0.3);
            border-top: 8px solid #3498db; /* Blue spinner */
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .controls-panel {
                top: auto;
                bottom: 10px;
                left: 50%;
                transform: translateX(-50%);
                width: calc(100% - 20px);
                justify-content: center;
            }
            .control-button {
                flex-grow: 1; /* Allow buttons to take more space on small screens */
            }
        }
    </style>
</head>
<body>
    <div id="loading-screen" class="loading-screen hidden">
        <div class="spinner"></div>
        <p>Loading 3D Map...</p>
    </div>

    <div id="container"></div>

    <div class="controls-panel">
        <button id="mapBackToArButton" class="control-button">Back to AR Scan</button>
        <button id="mapReturnToHomeButton" class="control-button">Return to Home</button>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/controls/OrbitControls.js';
        // Import FBXLoader instead of GLTFLoader
        import { FBXLoader } from 'https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/loaders/FBXLoader.js';

        let mapScene, mapCamera, mapRenderer, mapControls, mapRaycaster, mapMouse;
        let mapModel; // To store the loaded FBX model
        const hotspotLabels = {}; // To manage HTML labels for hotspots
        let currentHotspotHovered = null;

        const mapBackToArButton = document.getElementById('mapBackToArButton');
        const mapReturnToHomeButton = document.getElementById('mapReturnToHomeButton');
        const loadingScreen = document.getElementById('loading-screen'); // Get loading screen

        function showLoading() {
            loadingScreen.classList.remove('hidden');
        }

        function hideLoading() {
            loadingScreen.classList.add('hidden');
        }

        function initMapViewer() {
            const container = document.getElementById('container');

            // Scene
            mapScene = new THREE.Scene();
            mapScene.background = new THREE.Color(0xddeeff); // Light blue background

            // Camera
            mapCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            mapCamera.position.set(0, 5, 10); // Adjust camera position for your map size

            // Renderer
            mapRenderer = new THREE.WebGLRenderer({ antialias: true });
            mapRenderer.setPixelRatio(window.devicePixelRatio);
            mapRenderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(mapRenderer.domElement);

            // OrbitControls
            mapControls = new OrbitControls(mapCamera, mapRenderer.domElement);
            mapControls.enableDamping = true; // an animation loop is required when damping is enabled
            mapControls.dampingFactor = 0.05;
            mapControls.screenSpacePanning = false;
            mapControls.minDistance = 1; // Minimum zoom
            mapControls.maxDistance = 50; // Maximum zoom
            mapControls.maxPolarAngle = Math.PI / 2; // Prevent camera from going below the ground

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            mapScene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(5, 10, 7);
            mapScene.add(directionalLight);

            // Raycaster for interactions
            mapRaycaster = new THREE.Raycaster();
            mapMouse = new THREE.Vector2();

            // Loading Manager with progress updates
            const manager = new THREE.LoadingManager();
            manager.onStart = function (url, itemsLoaded, itemsTotal) {
                console.log('Started loading file: ' + url + '. Loaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.');
            };
            manager.onProgress = function (url, itemsLoaded, itemsTotal) {
                console.log('Loading file: ' + url + '. Loaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.');
            };
            manager.onLoad = function () {
                console.log('Loading complete!');
                hideLoading(); // Hide loading screen when all assets are loaded
            };
            manager.onError = function (url) {
                console.error('There was an error loading ' + url);
                hideLoading(); // Hide loading even on error
            };

            // FBX Loader
            const fbxLoader = new FBXLoader(manager);
            fbxLoader.load(
                'models/bukit_kiara_map.fbx', // Change to your FBX file path
                (fbx) => {
                    mapModel = fbx;
                    mapScene.add(mapModel);
                    console.log('FBX model loaded successfully:', mapModel);

                    // **Hotspot Logic for FBX**
                    // Since FBX doesn't have a direct 'extras' equivalent like GLB,
                    // you'll need to identify your hotspots differently.
                    // Common approaches:
                    // 1. Name your hotspot meshes/objects in your 3D software (e.g., "Hotspot_Checkpoint1").
                    //    Then iterate through children to find them.
                    // 2. Add invisible helper meshes in your 3D software at hotspot locations.
                    // 3. Define hotspot positions and target URLs in a separate JSON file
                    //    and programmatically create clickable spheres at those locations.

                    // Example (Assuming you've named your hotspot objects in Blender/etc. like "Hotspot_Checkpoint1"):
                    mapModel.traverse((child) => {
                        if (child.isMesh && child.name.startsWith('Hotspot_')) {
                            console.log(`Found potential hotspot mesh: ${child.name}`);
                            child.userData.isHotspot = true;

                            // You'll need a mapping from object name to target URL.
                            // This is a placeholder. You'll replace this with your actual URLs.
                            const hotspotData = {
                                'Hotspot_Checkpoint1': 'checkpoint_1.html',
                                'Hotspot_Checkpoint2': 'checkpoint_2.html', // Add more as needed
                                // ...
                            };

                            const hotspotName = child.name; // e.g., "Hotspot_Checkpoint1"
                            child.userData.targetUrl = hotspotData[hotspotName];
                            child.userData.name = hotspotName.replace('Hotspot_', '').replace(/([A-Z])/g, ' $1').trim(); // For display

                            // Create an HTML label for the hotspot
                            if (child.userData.targetUrl) {
                                const label = document.createElement('div');
                                label.className = 'hotspot-label';
                                label.textContent = child.userData.name;
                                document.body.appendChild(label);
                                hotspotLabels[child.uuid] = label; // Store with object's unique ID
                            }
                        }
                    });

                    // You might need to adjust camera or model scale after loading
                    const box = new THREE.Box3().setFromObject(mapModel);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());

                    // Center the model
                    mapModel.position.sub(center);

                    // Optional: Scale model if it's too big/small
                    // mapModel.scale.setScalar(1 / size.length() * desiredScale); // desiredScale ~ 5-10
                    // mapCamera.position.copy(center).add(new THREE.Vector3(0, size.y * 0.8, size.z * 1.5)); // Adjust camera to view model

                },
                (xhr) => {
                    // Progress callback for FBXLoader
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                },
                (error) => {
                    console.error('Error loading FBX model:', error);
                    // You can display an error message to the user here
                    alert('Failed to load 3D map. Please try again later.');
                }
            );

            window.addEventListener('resize', onWindowResize, false);
            mapRenderer.domElement.addEventListener('mousemove', onMapCanvasMouseMove, false);
            mapRenderer.domElement.addEventListener('click', onMapCanvasClick, false);

            animateMapViewer();
        }

        function onWindowResize() {
            mapCamera.aspect = window.innerWidth / window.innerHeight;
            mapCamera.updateProjectionMatrix();
            mapRenderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animateMapViewer() {
            requestAnimationFrame(animateMapViewer);
            mapControls.update(); // only required if controls.enableDamping is set to true
            mapRenderer.render(mapScene, mapCamera);

            // Update hotspot label positions
            if (mapModel) { // Ensure model is loaded
                mapModel.traverse((child) => {
                    if (child.isMesh && child.userData.isHotspot && hotspotLabels[child.uuid]) {
                        const label = hotspotLabels[child.uuid];
                        // Get the world position of the hotspot object
                        const hotspotWorldPosition = new THREE.Vector3();
                        child.getWorldPosition(hotspotWorldPosition);

                        // Project world position to screen position
                        hotspotWorldPosition.project(mapCamera);

                        const x = (hotspotWorldPosition.x * 0.5 + 0.5) * window.innerWidth;
                        const y = (-hotspotWorldPosition.y * 0.5 + 0.5) * window.innerHeight;

                        // Check if hotspot is in front of the camera and within bounds
                        if (hotspotWorldPosition.z < 1) { // z < 1 means it's in front of the camera
                            label.style.left = `${x}px`;
                            label.style.top = `${y}px`;
                            if (currentHotspotHovered === child) {
                                label.classList.add('visible');
                            } else {
                                label.classList.remove('visible');
                            }
                        } else {
                            label.classList.remove('visible'); // Hide if behind camera
                        }
                    }
                });
            }
        }

        function onMapCanvasMouseMove(event) {
            mapMouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mapMouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            mapRaycaster.setFromCamera(mapMouse, mapCamera);

            // Only intersect with the map model's children to find hotspots
            const intersects = mapRaycaster.intersectObjects(mapModel ? mapModel.children : [], true);

            let foundHotspot = false;
            for (const intersect of intersects) {
                if (intersect.object.userData.isHotspot) {
                    if (currentHotspotHovered !== intersect.object) {
                        currentHotspotHovered = intersect.object;
                        mapRenderer.domElement.style.cursor = 'pointer';
                        console.log(`Hovering over hotspot: ${intersect.object.userData.name}`);
                    }
                    foundHotspot = true;
                    break;
                }
            }

            if (!foundHotspot && currentHotspotHovered) {
                currentHotspotHovered = null;
                mapRenderer.domElement.style.cursor = 'grab'; // Default cursor for OrbitControls
            }
        }

        function onMapCanvasClick(event) {
            mapMouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mapMouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            mapRaycaster.setFromCamera(mapMouse, mapCamera);

            const intersects = mapRaycaster.intersectObjects(mapModel ? mapModel.children : [], true);

            for (const intersect of intersects) {
                if (intersect.object.userData.isHotspot && intersect.object.userData.targetUrl) {
                    const hotspotName = intersect.object.userData.name;
                    const targetUrl = intersect.object.userData.targetUrl;
                    console.log(`3D Hotspot clicked: ${hotspotName}. Redirecting to ${targetUrl}`);
                    showLoading();
                    window.location.href = targetUrl;
                    break;
                }
            }
        }

        mapBackToArButton.addEventListener('click', () => {
            showLoading();
            window.location.href = 'index.html';
        });

        mapReturnToHomeButton.addEventListener('click', () => {
            showLoading();
            window.location.href = 'index.html';
        });

        window.addEventListener('load', () => {
            showLoading(); // Show loading screen immediately on load
            initMapViewer();
            // hideLoading() will be called by loading manager onLoad event
        });
    </script>
</body>
</html>
