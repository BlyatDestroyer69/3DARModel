<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bukit Kiara AR World - WebXR Experience</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

    <!-- Embedded CSS from style.css -->
    <style>
        /* General Body and Font Styles */
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrolling on main body */
            font-family: 'Inter', sans-serif;
            background-color: #f0f0f0;
            color: #333;
        }

        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: #2c3e50; /* Dark blue background */
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* Ensure it's on top */
            transition: opacity 0.5s ease-out;
        }

        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none; /* Disable interaction when hidden */
        }

        .spinner {
            border: 8px solid rgba(255, 255, 255, 0.3);
            border-top: 8px solid #3498db; /* Blue spinner */
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Welcome Screen */
        .welcome-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d); /* Ocean sunset gradient */
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 100;
            transition: opacity 1s ease-in-out;
        }

        .welcome-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .welcome-screen h1 {
            font-size: 3em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .welcome-screen p {
            font-size: 1.2em;
            margin-bottom: 40px;
            max-width: 600px;
            line-height: 1.6;
        }

        /* Common Action Button Style */
        .action-button {
            background-color: #2ecc71; /* Green */
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 10px; /* Rounded corners */
            font-size: 1.5em;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            outline: none; /* Remove outline on focus */
        }

        .action-button:hover {
            background-color: #27ae60; /* Darker green on hover */
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }

        .action-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        /* MindAR A-Frame Scene */
        a-scene {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: block;
            opacity: 0; /* Initially hidden */
            transition: opacity 1s ease-in-out;
        }

        a-scene.active {
            opacity: 1; /* Visible when active */
        }

        /* Scan Message Overlay */
        .scan-message {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 1.1em;
            text-align: center;
            z-index: 50; /* Above AR scene */
            display: none; /* Hidden until AR scene is active */
            transition: background-color 0.3s ease;
        }

        /* WebXR AR Experience Container */
        .ar-experience {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: none; /* Hidden by default, activated by JS */
            flex-direction: column;
            justify-content: flex-end; /* Align UI to bottom */
            align-items: center;
            z-index: 10;
        }

        .ar-experience canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
            background-color: transparent; /* AR content will show camera feed */
        }

        /* AR Overlay UI for Buttons */
        .ar-overlay-ui {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 15px; /* Space between buttons */
            z-index: 12;
            pointer-events: none; /* Allow clicks to pass through to canvas by default */
            padding: 0 10px; /* Add some padding for smaller screens */
            box-sizing: border-box;
            flex-wrap: wrap; /* Allow buttons to wrap on small screens */
        }

        .ar-overlay-ui .action-button {
            pointer-events: all; /* Re-enable clicks for buttons */
            padding: 12px 20px; /* Slightly smaller buttons for AR UI */
            font-size: 1em;
            background-color: rgba(52, 152, 219, 0.8); /* Blue with transparency */
            border: 2px solid white;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .ar-overlay-ui .action-button:hover {
            background-color: rgba(41, 128, 185, 0.9); /* Darker blue on hover */
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }

        .ar-overlay-ui .action-button.hidden {
            display: none;
        }

        /* Camera Permission Message */
        .permission-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 15;
            display: none; /* Hidden by default */
        }

        .permission-message .action-button {
            margin-top: 15px;
            padding: 10px 20px;
            font-size: 1em;
            background-color: #e74c3c; /* Red for permission buttons */
        }

        .permission-message .action-button:hover {
            background-color: #c0392b;
        }

        .permission-message.hidden {
            display: none;
        }

        /* Fallback 3D Viewer */
        .fallback-viewer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: none; /* Hidden by default */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: #333; /* Dark background for fallback */
            color: white;
            z-index: 5;
        }

        .fallback-viewer canvas {
            width: 100% !important;
            height: 70vh !important; /* Take up most of the screen */
            display: block;
            background-color: #444;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .fallback-info {
            text-align: center;
            margin-top: 20px;
            padding: 0 20px;
        }

        .fallback-info h2 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .fallback-info p {
            font-size: 1.1em;
            line-height: 1.5;
            margin-bottom: 20px;
        }

        .fallback-info .action-button {
            background-color: #f39c12; /* Orange for fallback button */
        }

        .fallback-info .action-button:hover {
            background-color: #e67e22;
        }

        .fallback-viewer.active {
            display: flex;
        }

        /* Responsive Adjustments */
        @media (max-width: 768px) {
            .welcome-screen h1 {
                font-size: 2.2em;
            }
            .welcome-screen p {
                font-size: 1em;
                padding: 0 15px;
            }
            .action-button {
                padding: 12px 25px;
                font-size: 1.2em;
            }
            .scan-message {
                font-size: 1em;
                padding: 8px 15px;
            }
            .ar-overlay-ui {
                flex-direction: column; /* Stack buttons vertically */
                gap: 10px;
                bottom: 10px;
            }
            .ar-overlay-ui .action-button {
                width: calc(100% - 20px); /* Full width minus padding */
                max-width: 300px; /* Limit max width */
                margin: 0 auto; /* Center buttons */
            }
            .fallback-viewer canvas {
                height: 60vh !important;
            }
            .fallback-info h2 {
                font-size: 1.8em;
            }
            .fallback-info p {
                font-size: 0.9em;
            }
        }

        @media (max-width: 480px) {
            .welcome-screen h1 {
                font-size: 1.8em;
            }
            .welcome-screen p {
                font-size: 0.9em;
            }
            .action-button {
                padding: 10px 20px;
                font-size: 1em;
            }
            .scan-message {
                font-size: 0.9em;
                padding: 6px 12px;
            }
            .fallback-viewer canvas {
                height: 50vh !important;
            }
        }
    </style>

    <!-- A-Frame and MindAR.js for initial marker detection -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.1/dist/mindar-image-aframe.prod.js"></script>

    <!-- Three.js and its addons for WebXR and 3D rendering -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading-screen" class="loading-screen">
        <div class="spinner"></div>
        <p>Loading AR World...</p>
    </div>

    <!-- Welcome Screen -->
    <div id="welcome-screen" class="welcome-screen">
        <h1>Welcome to Bukit Kiara AR World!</h1>
        <p>Scan the special map to unlock the interactive 3D experience.</p>
        <button id="welcome-button" class="action-button">Start Scanning</button>
    </div>

    <!-- MindAR A-Frame Scene for Marker Detection -->
    <a-scene
        id="ar-scan-scene"
        mindar-image="imageTargetSrc: ./assets/targets.mind; showImage: false;"
        vr-mode-ui="enabled: false"
        device-orientation-permission-ui="enabled: false"
        visible="false"
        loading-screen="enabled: false"
    >
        <!-- This entity will listen for the targetFound event -->
        <a-entity mindar-image-target="targetIndex: 0"></a-entity>
        <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>
    </a-scene>

    <!-- Message Overlay for Scanning -->
    <div id="scan-message" class="scan-message">Please scan the Bukit Kiara map.</div>

    <!-- WebXR AR Experience Container -->
    <div id="ar-experience" class="ar-experience">
        <canvas id="ar-canvas"></canvas>
        <div id="ar-overlay-ui" class="ar-overlay-ui">
            <button id="place-model-button" class="action-button hidden">Place Model</button>
            <button id="reset-model-button" class="action-button hidden">Reset Model</button>
            <button id="toggle-manipulation-button" class="action-button hidden">Enable Manipulation</button>
        </div>
        <div id="camera-permission-message" class="permission-message hidden">
            <p>Please grant camera access to experience AR.</p>
            <button id="grant-camera-button" class="action-button">Grant Access</button>
        </div>
        <div id="ar-unsupported-message" class="permission-message hidden">
            <p>Your browser or device does not support WebXR AR. Falling back to 3D viewer mode.</p>
            <button id="return-to-home" class="action-button">Return to Home</button>
        </div>
    </div>

    <!-- Fallback 3D Viewer Container (for non-AR devices) -->
    <div id="fallback-viewer" class="fallback-viewer">
        <canvas id="fallback-canvas"></canvas>
        <div class="fallback-info">
            <h2>3D Model Viewer</h2>
            <p>This is a fallback 3D viewer because your device does not support WebXR AR. You can drag to rotate the model.</p>
            <button id="fallback-return-button" class="action-button">Return to Home</button>
        </div>
    </div>

    <!-- Embedded JavaScript from main.js -->
    <script type="module">
        import * as THREE from 'three';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js'; // Changed to FBXLoader
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // --- DOM Elements ---
        const loadingScreen = document.getElementById('loading-screen');
        const welcomeScreen = document.getElementById('welcome-screen');
        const welcomeButton = document.getElementById('welcome-button');
        const arScanScene = document.getElementById('ar-scan-scene');
        const scanMessage = document.getElementById('scan-message');
        const arExperienceDiv = document.getElementById('ar-experience');
        const arCanvas = document.getElementById('ar-canvas');
        const placeModelButton = document.getElementById('place-model-button');
        const resetModelButton = document.getElementById('reset-model-button');
        const toggleManipulationButton = document.getElementById('toggle-manipulation-button');
        const cameraPermissionMessage = document.getElementById('camera-permission-message');
        const grantCameraButton = document.getElementById('grant-camera-button');
        const arUnsupportedMessage = document.getElementById('ar-unsupported-message');
        const returnToHomeButton = document.getElementById('return-to-home');
        const fallbackViewerDiv = document.getElementById('fallback-viewer');
        const fallbackCanvas = document.getElementById('fallback-canvas');
        const fallbackReturnButton = document.getElementById('fallback-return-button');

        // --- Three.js & WebXR Variables ---
        let arScene, arCamera, arRenderer, arSession;
        let arReferenceSpace;
        let arHitTestSource = null;
        let arLoadedModel = null;
        let reticle = null;
        let modelPlaced = false;
        let transformControls = null;
        let manipulationEnabled = false;

        // --- Fallback Viewer Variables ---
        let fallbackScene, fallbackCamera, fallbackRenderer, fallbackControls;
        let fallbackLoadedModel = null;
        let fallbackAnimateId = null;

        // --- Loading Manager ---
        const manager = new THREE.LoadingManager();
        manager.onStart = function (url, itemsLoaded, itemsTotal) {
            console.log('Started loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.');
            loadingScreen.classList.remove('hidden');
        };
        manager.onLoad = function () {
            console.log('Loading complete!');
            // Hide loading screen after a small delay to ensure everything is rendered
            setTimeout(() => {
                loadingScreen.classList.add('hidden');
            }, 500);
        };
        manager.onProgress = function (url, itemsLoaded, itemsTotal) {
            console.log('Loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.');
        };
        manager.onError = function (url) {
            console.error('There was an error loading ' + url);
            loadingScreen.classList.add('hidden'); // Hide loading screen even on error
        };

        // Changed from GLTFLoader to FBXLoader
        const fbxLoader = new FBXLoader(manager);

        // --- Model Paths (Customize these) ---
        // IMPORTANT: Replace 'YOUR_HOSTED_MODEL_URL_HERE' with the actual URL from your hosting service.
        // Also, ensure your FBX file is named 'bukit_kiara_map.fbx' or update the filename accordingly.
        const AR_MODEL_PATH = 'YOUR_HOSTED_MODEL_URL_HERE/bukit_kiara_map.fbx'; // Your 3D map model (FBX)
        const FALLBACK_MODEL_PATH = 'YOUR_HOSTED_MODEL_URL_HERE/bukit_kiara_map.fbx'; // Same model for fallback (FBX)

        // --- Event Listeners ---
        welcomeButton.addEventListener('click', () => {
            welcomeScreen.classList.add('hidden');
            welcomeScreen.addEventListener('transitionend', () => {
                // Check for WebXR support first
                if (navigator.xr && navigator.xr.isSessionSupported) {
                    navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
                        if (supported) {
                            // If AR is supported, activate MindAR for initial scan
                            arScanScene.setAttribute('visible', 'true');
                            arScanScene.classList.add('active');
                            scanMessage.style.display = 'block';
                            console.log("AR Scanner Activated. Please scan the map target.");
                        } else {
                            // If AR is not supported, go straight to fallback viewer
                            console.warn("Immersive AR not supported on this device. Showing fallback 3D viewer.");
                            showFallbackViewer();
                        }
                    }).catch(e => {
                        console.error("Error checking WebXR support:", e);
                        // Using a custom message box instead of alert
                        showCustomMessage("An error occurred checking WebXR support. Falling back to 3D viewer.", () => {
                            showFallbackViewer();
                        });
                    });
                } else {
                    // WebXR not supported at all
                    console.warn("WebXR is not supported by this browser. Showing fallback 3D viewer.");
                    showFallbackViewer();
                }
            }, { once: true });
        });

        // MindAR target found event
        document.addEventListener('DOMContentLoaded', () => {
            const mindarImageTargetEntity = document.querySelector('a-entity[mindar-image-target]');

            if (mindarImageTargetEntity) {
                mindarImageTargetEntity.addEventListener('targetFound', () => {
                    console.log("Map Target Found! Initiating WebXR AR experience...");
                    scanMessage.textContent = "Map detected! Preparing AR experience...";
                    scanMessage.style.backgroundColor = 'rgba(46, 204, 113, 0.8)'; // Green background

                    // Hide MindAR scene and message
                    arScanScene.classList.remove('active');
                    arScanScene.setAttribute('visible', 'false');
                    scanMessage.style.display = 'none';

                    // Start WebXR AR experience
                    startWebXR();
                }, { once: true }); // Use { once: true } to only trigger once
            } else {
                console.error("MindAR image target entity not found. Is your A-Frame scene correctly structured?");
            }

            // Initial check for WebXR support on page load to set up fallback if needed
            if (!navigator.xr || !navigator.xr.isSessionSupported) {
                console.warn("WebXR API not detected. Fallback 3D viewer will be used.");
            }
        });

        grantCameraButton.addEventListener('click', async () => {
            cameraPermissionMessage.classList.add('hidden'); // Hide message temporarily
            // Attempt to access camera to trigger permission prompt
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                stream.getTracks().forEach(track => track.stop()); // Stop stream immediately
                console.log("Camera access granted. Retrying AR experience.");
                startWebXR(); // Retry entering AR
            } catch (err) {
                console.error("Failed to grant camera access:", err);
                // Using a custom message box instead of alert
                showCustomMessage("Camera access denied. AR experience cannot proceed without camera permission.", () => {
                    cameraPermissionMessage.classList.remove('hidden'); // Re-show message if still denied
                });
            }
        });

        returnToHomeButton.addEventListener('click', () => {
            arUnsupportedMessage.classList.add('hidden');
            welcomeScreen.classList.remove('hidden');
        });

        fallbackReturnButton.addEventListener('click', () => {
            disposeFallbackViewer();
            fallbackViewerDiv.classList.remove('active');
            welcomeScreen.classList.remove('hidden');
        });

        placeModelButton.addEventListener('click', onPlaceModelButtonClick);
        resetModelButton.addEventListener('click', onResetModelButtonClick);
        toggleManipulationButton.addEventListener('click', onToggleManipulationButtonClick);

        // --- WebXR AR Functions ---
        async function startWebXR() {
            try {
                const session = await navigator.xr.requestSession('immersive-ar', {
                    requiredFeatures: ['hit-test', 'dom-overlay'],
                    domOverlay: { root: arOverlayUi } // Use arOverlayUi as the DOM overlay
                });
                console.log("WebXR immersive-ar session requested.");
                await initWebXR(session);
            } catch (e) {
                console.error("Error starting WebXR AR session:", e);
                if (e.name === 'NotAllowedError' || e.name === 'SecurityError') {
                    // Camera access denied or not over HTTPS
                    cameraPermissionMessage.classList.remove('hidden');
                    // Using a custom message box instead of alert
                    showCustomMessage("AR experience requires camera access. Please grant camera permission and ensure the site is served over HTTPS.", () => {
                        // No action on close, just acknowledge
                    });
                } else {
                    arUnsupportedMessage.classList.remove('hidden');
                    // Using a custom message box instead of alert
                    showCustomMessage("AR experience could not be started. Error: " + e.message + "\nFalling back to 3D model viewer.", () => {
                        showFallbackViewer();
                    });
                }
            }
        }

        async function initWebXR(session) {
            arSession = session;
            arSession.addEventListener('end', onXRSessionEnded);

            arRenderer = new THREE.WebGLRenderer({
                alpha: true,
                preserveDrawingBuffer: true,
                canvas: arCanvas,
                context: arCanvas.getContext('webgl', { xrCompatible: true })
            });
            arRenderer.autoClear = false;
            arRenderer.setPixelRatio(window.devicePixelRatio);
            arRenderer.setSize(arCanvas.clientWidth, arCanvas.clientHeight);
            arRenderer.outputEncoding = THREE.sRGBEncoding;
            arRenderer.xr.enabled = true;
            arRenderer.xr.setReferenceSpaceType('viewer'); // 'viewer' for initial hit-test, then 'local-floor' for stable placement
            arRenderer.xr.setSession(arSession);

            arScene = new THREE.Scene();

            // Lighting for AR scene
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
            arScene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(0, 5, 0);
            arScene.add(directionalLight);

            // Reticle for hit-testing
            const geometry = new THREE.RingGeometry(0.1, 0.12, 32).rotateX(- Math.PI / 2);
            const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
            reticle = new THREE.Mesh(geometry, material);
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            arScene.add(reticle);

            // Load the 3D model using FBXLoader
            fbxLoader.load(AR_MODEL_PATH, (fbx) => { // Changed gltf to fbx
                arLoadedModel = fbx; // FBXLoader returns the scene directly
                // Scale the model to a reasonable size for AR
                const box = new THREE.Box3().setFromObject(arLoadedModel);
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const scaleFactor = 0.5 / maxDim; // Scale to fit within 0.5 units
                arLoadedModel.scale.set(scaleFactor, scaleFactor, scaleFactor);
                arLoadedModel.visible = false; // Hide until placed
                arScene.add(arLoadedModel);
                console.log("AR Model loaded successfully (FBX).");

                // Set up TransformControls
                transformControls = new TransformControls(arCamera, arRenderer.domElement);
                transformControls.attach(arLoadedModel);
                transformControls.setMode("translate"); // Default mode
                transformControls.visible = false; // Hidden initially
                transformControls.enabled = false; // Disabled initially
                arScene.add(transformControls);

                // Disable XR input when TransformControls are active
                transformControls.addEventListener('dragging-changed', function (event) {
                    arSession.inputSources.forEach(source => {
                        if (source.hand === 'right' || source.hand === 'left') { // Adjust for specific controllers if needed
                            // For WebXR, input sources are managed by the session.
                            // We can't directly disable them, but we can prevent our own logic from firing.
                        }
                    });
                    arRenderer.xr.enabled = !event.value; // Pause XR rendering if dragging
                });

            }, undefined, (error) => {
                console.error('Error loading AR FBX model:', error); // Changed error message
                showCustomMessage("Error loading 3D model for AR. Please try again later.", () => {});
            });

            arReferenceSpace = await arSession.requestReferenceSpace('viewer');
            arHitTestSource = await arSession.requestHitTestSource({ space: arReferenceSpace });

            arExperienceDiv.style.display = 'flex'; // Show AR experience container
            placeModelButton.classList.remove('hidden'); // Show place button
            resetModelButton.classList.add('hidden'); // Hide reset button initially
            toggleManipulationButton.classList.add('hidden'); // Hide manipulation button initially

            arRenderer.setAnimationLoop(animateWebXR);

            // Add event listener for selecting (tapping) on the canvas
            arCanvas.addEventListener('click', onARCanvasClick);

            // Initial state
            modelPlaced = false;
        }

        function onXRSessionEnded() {
            console.log("XR Session Ended.");
            disposeARExperience();
            arExperienceDiv.style.display = 'none';
            welcomeScreen.classList.remove('hidden'); // Return to welcome screen
        }

        function animateWebXR(timestamp, frame) {
            if (!frame) return;

            const referenceSpace = arRenderer.xr.getReferenceSpace();

            if (arLoadedModel && !modelPlaced && arHitTestSource) {
                const hitTestResults = frame.getHitTestResults(arHitTestSource);

                if (hitTestResults.length > 0) {
                    const hitPose = hitTestResults[0].getPose(referenceSpace);
                    reticle.matrix.copy(hitPose.transform.matrix);
                    reticle.visible = true;
                    placeModelButton.classList.remove('hidden'); // Show place button if surface detected
                } else {
                    reticle.visible = false;
                    placeModelButton.classList.add('hidden'); // Hide place button if no surface
                }
            }

            // Render the scene with the XR camera
            arRenderer.render(arScene, arRenderer.xr.getCamera(new THREE.PerspectiveCamera()));
        }

        function onARCanvasClick(event) {
            if (arSession && arLoadedModel && !modelPlaced && reticle.visible) {
                // Place model at reticle position
                arLoadedModel.position.setFromMatrixPosition(reticle.matrix);
                arLoadedModel.quaternion.setFromRotationMatrix(reticle.matrix);
                arLoadedModel.visible = true;
                modelPlaced = true;
                reticle.visible = false;
                placeModelButton.classList.add('hidden');
                resetModelButton.classList.remove('hidden');
                toggleManipulationButton.classList.remove('hidden');
                console.log("AR Model placed at:", arLoadedModel.position);
            }
        }

        function onPlaceModelButtonClick() {
            // This button provides an explicit way to place the model,
            // useful if click events are not reliably triggered or for accessibility.
            if (arSession && arLoadedModel && !modelPlaced && reticle.visible) {
                arLoadedModel.position.setFromMatrixPosition(reticle.matrix);
                arLoadedModel.quaternion.setFromRotationMatrix(reticle.matrix);
                arLoadedModel.visible = true;
                modelPlaced = true;
                reticle.visible = false;
                placeModelButton.classList.add('hidden');
                resetModelButton.classList.remove('hidden');
                toggleManipulationButton.classList.remove('hidden');
                console.log("AR Model placed via button at:", arLoadedModel.position);
            }
        }

        function onResetModelButtonClick() {
            modelPlaced = false;
            if (arLoadedModel) {
                arLoadedModel.visible = false;
            }
            if (transformControls) {
                transformControls.detach();
                transformControls.visible = false;
                transformControls.enabled = false;
                manipulationEnabled = false;
                toggleManipulationButton.textContent = "Enable Manipulation";
            }
            placeModelButton.classList.remove('hidden');
            resetModelButton.classList.add('hidden');
            toggleManipulationButton.classList.add('hidden');
            console.log("AR Model reset.");
        }

        function onToggleManipulationButtonClick() {
            if (!arLoadedModel) return;

            manipulationEnabled = !manipulationEnabled;

            if (manipulationEnabled) {
                transformControls.attach(arLoadedModel);
                transformControls.setMode("translate"); // Default mode for manipulation
                transformControls.visible = true;
                transformControls.enabled = true;
                toggleManipulationButton.textContent = "Disable Manipulation";
                console.log("Manipulation enabled.");
            } else {
                transformControls.detach();
                transformControls.visible = false;
                transformControls.enabled = false;
                toggleManipulationButton.textContent = "Enable Manipulation";
                console.log("Manipulation disabled.");
            }
        }

        function disposeARExperience() {
            if (arSession) {
                arSession.end();
                arSession = null;
            }
            if (arHitTestSource) {
                arHitTestSource.cancel();
                arHitTestSource = null;
            }
            if (arRenderer) {
                arRenderer.setAnimationLoop(null); // Stop animation loop
                arRenderer.dispose();
                arRenderer = null;
            }
            if (arScene) {
                arScene.traverse(obj => {
                    if (obj.isMesh) {
                        if (obj.geometry) obj.geometry.dispose();
                        if (obj.material) {
                            if (Array.isArray(obj.material)) {
                                obj.material.forEach(material => material.dispose());
                            } else {
                                obj.material.dispose();
                            }
                        }
                    }
                });
                arScene.clear();
                arScene = null;
            }
            if (arLoadedModel) {
                arLoadedModel = null;
            }
            if (reticle) {
                if (arScene) arScene.remove(reticle);
                if (reticle.geometry) reticle.geometry.dispose();
                if (reticle.material) reticle.material.dispose();
                reticle = null;
            }
            if (transformControls) {
                transformControls.dispose();
                transformControls = null;
            }
            arCanvas.removeEventListener('click', onARCanvasClick);
            placeModelButton.classList.add('hidden');
            resetModelButton.classList.add('hidden');
            toggleManipulationButton.classList.add('hidden');
            modelPlaced = false;
            manipulationEnabled = false;
        }

        // --- Fallback 3D Viewer Functions ---
        function showFallbackViewer() {
            welcomeScreen.classList.add('hidden');
            arExperienceDiv.style.display = 'none';
            arUnsupportedMessage.classList.add('hidden');
            fallbackViewerDiv.classList.add('active'); // Show fallback viewer

            initFallbackViewer();
        }

        function initFallbackViewer() {
            disposeFallbackViewer(); // Clean up any previous instance

            fallbackScene = new THREE.Scene();
            fallbackScene.background = new THREE.Color(0x222222); // Dark background

            fallbackCamera = new THREE.PerspectiveCamera(75, fallbackCanvas.clientWidth / fallbackCanvas.clientHeight, 0.1, 1000);
            fallbackCamera.position.set(0, 1.5, 3); // Position camera to view model

            fallbackRenderer = new THREE.WebGLRenderer({ canvas: fallbackCanvas, antialias: true });
            fallbackRenderer.setSize(fallbackCanvas.clientWidth, fallbackCanvas.clientHeight);
            fallbackRenderer.setPixelRatio(window.devicePixelRatio);
            fallbackRenderer.outputEncoding = THREE.sRGBEncoding;

            fallbackControls = new OrbitControls(fallbackCamera, fallbackRenderer.domElement);
            fallbackControls.enableDamping = true;
            fallbackControls.dampingFactor = 0.1;
            fallbackControls.minDistance = 1;
            fallbackControls.maxDistance = 10;
            fallbackControls.autoRotate = true; // Auto-rotate for aesthetic
            fallbackControls.autoRotateSpeed = 0.5;

            // Lighting for fallback scene
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            fallbackScene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(5, 10, 7);
            fallbackScene.add(directionalLight);

            // Load the 3D model for fallback using FBXLoader
            fbxLoader.load(FALLBACK_MODEL_PATH, (fbx) => { // Changed gltf to fbx
                fallbackLoadedModel = fbx; // FBXLoader returns the scene directly

                const box = new THREE.Box3().setFromObject(fallbackLoadedModel);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());

                // Scale the model to fit within the fallback view
                const maxDim = Math.max(size.x, size.y, size.z);
                const scaleFactor = 1.5 / maxDim;
                fallbackLoadedModel.scale.set(scaleFactor, scaleFactor, scaleFactor);

                box.setFromObject(fallbackLoadedModel); // Recalculate box after scaling
                box.getCenter(center);
                fallbackLoadedModel.position.sub(center); // Center the model

                fallbackScene.add(fallbackLoadedModel);
                console.log("Fallback model loaded (FBX).");
            }, undefined, (error) => {
                console.error('Error loading fallback FBX model:', error); // Changed error message
                showCustomMessage("Error loading 3D model for fallback viewer.", () => {});
            });

            animateFallbackViewer();
            window.addEventListener('resize', onFallbackWindowResize);
        }

        function animateFallbackViewer() {
            if (fallbackRenderer) {
                fallbackAnimateId = requestAnimationFrame(animateFallbackViewer);
                if (fallbackControls) fallbackControls.update();
                fallbackRenderer.render(fallbackScene, fallbackCamera);
            }
        }

        function onFallbackWindowResize() {
            if (fallbackCamera && fallbackRenderer && fallbackCanvas) {
                fallbackCamera.aspect = fallbackCanvas.clientWidth / fallbackCanvas.clientHeight;
                fallbackCamera.updateProjectionMatrix();
                fallbackRenderer.setSize(fallbackCanvas.clientWidth, fallbackCanvas.clientHeight);
            }
        }

        function disposeFallbackViewer() {
            if (fallbackAnimateId) {
                cancelAnimationFrame(fallbackAnimateId);
                fallbackAnimateId = null;
            }
            if (fallbackScene) {
                fallbackScene.traverse(obj => {
                    if (obj.isMesh) {
                        if (obj.geometry) obj.geometry.dispose();
                        if (obj.material) {
                            if (Array.isArray(obj.material)) {
                                obj.material.forEach(material => material.dispose());
                            } else {
                                obj.material.dispose();
                            }
                        }
                    }
                });
                fallbackScene.clear();
                fallbackScene = null;
            }
            if (fallbackRenderer) {
                fallbackRenderer.dispose();
                fallbackRenderer = null;
            }
            if (fallbackControls) {
                fallbackControls.dispose();
                fallbackControls = null;
            }
            if (fallbackLoadedModel) {
                fallbackLoadedModel = null;
            }
            window.removeEventListener('resize', onFallbackWindowResize);
        }

        // --- Custom Message Box (instead of alert) ---
        function showCustomMessage(message, onCloseCallback) {
            const messageBox = document.createElement('div');
            messageBox.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background-color: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 25px;
                border-radius: 12px;
                text-align: center;
                z-index: 2000;
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
                max-width: 80vw;
                font-size: 1.1em;
                line-height: 1.5;
            `;
            messageBox.innerHTML = `
                <p>${message}</p>
                <button style="
                    background-color: #3498db;
                    color: white;
                    padding: 10px 20px;
                    border: none;
                    border-radius: 8px;
                    font-size: 1em;
                    cursor: pointer;
                    margin-top: 20px;
                    transition: background-color 0.3s ease;
                ">OK</button>
            `;
            document.body.appendChild(messageBox);

            messageBox.querySelector('button').addEventListener('click', () => {
                document.body.removeChild(messageBox);
                if (onCloseCallback) {
                    onCloseCallback();
                }
            });
        }

        // --- Hotspot / Checkpoint Logic (Bonus Feature - Conceptual Outline) ---
        // This would involve:
        // 1. Defining hotspot data (position, associated info, target URL) within your FBX model's userData
        //    or in a separate JSON file.
        // 2. In the FBXLoader callback (for arLoadedModel), iterate through the model's children
        //    or specific nodes to find where hotspots should be.
        // 3. Create small Three.js objects (e.g., small spheres or custom meshes) at these positions.
        // 4. Implement raycasting for interaction:
        //    - For AR: Listen for 'select' events on the XR session. When a select event occurs,
        //      use the XR input source's ray to intersect with the hotspot objects.
        //    - For Fallback: Listen for 'click' events on the fallbackCanvas. Use a standard
        //      mouse raycaster to intersect.
        // 5. When a hotspot is intersected/clicked, display its information (e.g., in a pop-up UI)
        //    or navigate to a target URL (like your checkpoint_1.html).

        // Example of a simple hotspot creation (to be adapted for your model structure):
        /*
        function createHotspotMesh(position, name, url) {
            const hotspotGeometry = new THREE.SphereGeometry(0.05, 16, 16);
            const hotspotMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.7 });
            const hotspot = new THREE.Mesh(hotspotGeometry, hotspotMaterial);
            hotspot.position.copy(position);
            hotspot.name = name; // For identification during raycasting
            hotspot.userData.targetUrl = url; // Store associated data
            return hotspot;
        }

        // In the fbxLoader.load success callback for arLoadedModel:
        // arLoadedModel.traverse((node) => {
        //     if (node.isMesh && node.name.startsWith('Hotspot_')) { // Example naming convention
        //         const hotspot = createHotspotMesh(node.position.clone(), node.name, node.userData.url);
        //         arLoadedModel.add(hotspot); // Add hotspot relative to the model
        //     }
        // });

        // For raycasting in AR:
        // arSession.addEventListener('select', (event) => {
        //     if (modelPlaced && arLoadedModel && event.inputSource.targetRaySpace) {
        //         const controller = arRenderer.xr.getController(event.inputSource.handedness === 'right' ? 0 : 1); // Get controller
        //         if (controller) {
        //             const raycaster = new THREE.Raycaster();
        //             raycaster.setFromXRController(controller);
        //             const intersects = raycaster.intersectObjects(arLoadedModel.children, true);
        //             for (const intersect of intersects) {
        //                 if (intersect.object.userData.targetUrl) {
        //                     console.log("Hotspot clicked:", intersect.object.name);
        //                     window.location.href = intersect.object.userData.targetUrl;
        //                     break;
        //                 }
        //             }
        //         }
        //     }
        // });
        */
    </script>
</body>
</html>
